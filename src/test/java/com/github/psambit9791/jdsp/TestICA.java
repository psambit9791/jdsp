/*
 *
 *  * Copyright (c) 2020 Sambit Paul
 *  *
 *  * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *  *
 *  * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *  *
 *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

package com.github.psambit9791.jdsp;

import com.github.psambit9791.jdsp.misc.Plotting;
import com.github.psambit9791.jdsp.misc.UtilMethods;
import com.github.psambit9791.jdsp.transform.ICA;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;

public class TestICA {
    // Mixing Ratio = Component1: [1.0, 1.0, 1.0], Component2: [0.5, 2.0, 1.0], Component3: [1.5, 1.0, 2.0]
    final double[] func_input = {0.38, 0.53, 0.80, 0.86, 0.11, 0.88, 0.72, 0.87, 0.37, 0.52};
    // 2Hz Sine + 12Hz Sine + 26Hz Sine
    final double[][] X_fit = {{0.85578, 0.74023, 1.34534}, {1.07739, 0.40654, 1.98131}, {2.0507, 1.91981, 3.23426}, {1.2674, 0.33323, 2.56414}, {2.12663, 2.42052, 3.37158}, {0.43881, -0.3084, 1.49951}, {1.38468, 2.33925, 2.1829}, {-0.71001, -1.16909, -0.19044}, {0.69305, 2.08902, 0.97242}, {-1.31433, -1.78986, -1.20207}, {0.66586, 1.99043, 0.69172}, {-1.12138, -1.99507, -1.1204}, {1.12138, 1.99507, 1.1204}, {-0.66586, -1.99043, -0.69172}, {1.31433, 1.78986, 1.20207}, {-0.69305, -2.08902, -0.97242}, {0.71001, 1.16909, 0.19044}, {-1.38468, -2.33925, -2.1829}, {-0.43881, 0.3084, -1.49951}, {-2.12663, -2.42052, -3.37158}, {-1.2674, -0.33323, -2.56414}, {-2.0507, -1.91981, -3.23426}, {-1.07739, -0.40654, -1.98131}, {-0.85578, -0.74023, -1.34534}, {0.0, 0.0, 0.0}};
    // 3Hz Sine + 13Hz Sine + 24Hz Sine
    final double[][] X_tr = {{0.31052, -0.15708, 0.40411}, {0.76496, 0.51464, 0.78222}, {-0.28216, -1.03554, -0.58145}, {-0.23724, 0.18185, -1.0189}, {-2.12663, -2.42052, -3.37158}, {-1.29577, -0.12008, -2.78494}, {-2.59713, -2.94548, -4.00158}, {-0.30919, 0.65948, -1.33836}, {-1.19359, -2.33929, -1.72322}, {1.31433, 1.78986, 1.20207}, {-0.44558, -1.88029, -0.3613}, {1.24082, 2.05478, 1.29955}, {-1.24082, -2.05478, -1.29955}, {0.44558, 1.88029, 0.3613}, {-1.31433, -1.78986, -1.20207}, {1.19359, 2.33929, 1.72322}, {0.30919, -0.65948, 1.33836}, {2.59713, 2.94548, 4.00158}, {1.29577, 0.12008, 2.78494}, {2.12663, 2.42052, 3.37158}, {0.23724, -0.18185, 1.0189}, {0.28216, 1.03554, 0.58145}, {-0.76496, -0.51464, -0.78222}, {-0.31052, 0.15708, -0.40411}, {-0.0, 0.0, -0.0}};
    final double[][] w_init = {{-0.34889445,  0.98370343,  0.58092283}, {0.07028444,  0.77753268,  0.58195875}, {1.47179053,  1.66318101, -0.26117712}};

    // FUNCTIONS
    @Test
    public void ICAFuncLogcoshTest1() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        double[] gx= {0.36271, 0.48538, 0.66404, 0.69626, 0.10956, 0.70642, 0.61691, 0.70137, 0.35399, 0.4777};
        double g_x = 0.69701;
        ICA i1 = new ICA(this.X_fit);
        Method privMethod = i1.getClass().getDeclaredMethod("logcosh_", double[].class);
        privMethod.setAccessible(true);
        privMethod.invoke(i1, (Object) this.func_input);
        Assertions.assertArrayEquals(gx, i1.gx, 0.00001);
        Assertions.assertEquals(g_x, i1.g_x, 0.00001);
    }

    @Test
    public void ICAFuncExpTest1() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        double[] gx= {0.35353, 0.46055, 0.58092, 0.59415, 0.10934, 0.59748, 0.5556, 0.59588, 0.34552, 0.45424};
        double g_x = 0.49788;
        ICA i1 = new ICA(this.X_fit);
        Method privMethod = i1.getClass().getDeclaredMethod("exp_", double[].class);
        privMethod.setAccessible(true);
        privMethod.invoke(i1, (Object) this.func_input);
        Assertions.assertArrayEquals(gx, i1.gx, 0.00001);
        Assertions.assertEquals(g_x, i1.g_x, 0.00001);
    }

    @Test
    public void ICAFuncCubeTest1() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        double[] gx= {0.05487, 0.14888, 0.512  , 0.63606, 0.00133, 0.68147, 0.37325, 0.6585 , 0.05065, 0.14061};
        double g_x = 1.2822;
        ICA i1 = new ICA(this.X_fit);
        Method privMethod = i1.getClass().getDeclaredMethod("cube_", double[].class);
        privMethod.setAccessible(true);
        privMethod.invoke(i1, (Object) this.func_input);
        Assertions.assertArrayEquals(gx, i1.gx, 0.00001);
        Assertions.assertEquals(g_x, i1.g_x, 0.00001);
    }

    // UNIT VARIANCE
    @Test
    public void ICAUnitVarLogcoshTest1() {
        ICA obj = new ICA(this.X_fit, "logcosh", this.w_init, 200, 1E-4, 1);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{0.35113, 0.68158, -0.17729}, {0.68033, 1.19464, 0.35163}, {0.96692, 1.4122, -0.52069}, {1.19302, 1.28063, 0.68122}, {1.34429, 0.83233, -0.83132}, {1.4113, 0.17845, 0.96806}, {1.38957, -0.51951, -1.08968}, {1.28054, -1.08856, 1.19408}, {1.09079, -1.38832, -1.27958}, {0.83239, -1.34425, 1.34504}, {0.52137, -0.96773, -1.38913}, {0.17757, -0.35149, 1.41143}, {-0.17757, 0.35149, -1.41143}, {-0.52137, 0.96773, 1.38913}, {-0.83239, 1.34425, -1.34504}, {-1.09079, 1.38832, 1.27958}, {-1.28054, 1.08856, -1.19408}, {-1.38957, 0.51951, 1.08968}, {-1.4113, -0.17845, -0.96806}, {-1.34429, -0.83233, 0.83132}, {-1.19302, -1.28063, -0.68122}, {-0.96692, -1.4122, 0.52069}, {-0.68033, -1.19464, -0.35163}, {-0.35113, -0.68158, 0.17729}, {0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{-0.3525, 0.96781, 0.17721}, {-0.68247, 1.41085, -0.35175}, {-0.96898, 1.08889, 0.52058}, {-1.19422, 0.17623, -0.68128}, {-1.34429, -0.83233, 0.83132}, {-1.4103, -1.39037, -0.968}, {-1.38815, -1.19516, 1.08975}, {-1.27936, -0.35281, -1.19402}, {-1.0902, 0.68046, 1.27961}, {-0.83239, 1.34425, -1.34504}, {-0.52163, 1.27925, 1.38912}, {-0.17771, 0.5204, -1.41144}, {0.17771, -0.5204, 1.41144}, {0.52163, -1.27925, -1.38912}, {0.83239, -1.34425, 1.34504}, {1.0902, -0.68046, -1.27961}, {1.27936, 0.35281, 1.19402}, {1.38815, 1.19516, -1.08975}, {1.4103, 1.39037, 0.968}, {1.34429, 0.83233, -0.83132}, {1.19422, -0.17623, 0.68128}, {0.96898, -1.08889, -0.52058}, {0.68247, -1.41085, 0.35175}, {0.3525, -0.96781, -0.17721}, {-0.0, -0.0, -0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    @Test
    public void ICAUnitVarLogcoshTest2() {
        ICA obj = new ICA(this.X_fit, "logcosh", "unit-variance", this.w_init, 200, 1E-4, 1.5);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{0.28371, 0.68079, 0.27444}, {1.06174, 0.84818, 0.40858}, {0.56048, 1.64764, 0.41412}, {1.57375, 1.01883, 0.1126}, {0.21888, 1.75451, -0.25449}, {1.43443, 0.40355, -0.8604}, {-0.53806, 1.21721, -1.27165}, {1.03497, -0.47928, -1.71747}, {-1.17712, 0.68318, -1.70359}, {0.8686, -0.97928, -1.61107}, {-1.32152, 0.61767, -1.00503}, {1.07178, -0.89703, -0.44029}, {-1.07178, 0.89703, 0.44029}, {1.32152, -0.61767, 1.00503}, {-0.8686, 0.97928, 1.61107}, {1.17712, -0.68318, 1.70359}, {-1.03497, 0.47928, 1.71747}, {0.53806, -1.21721, 1.27165}, {-1.43443, -0.40355, 0.8604}, {-0.21888, -1.75451, 0.25449}, {-1.57375, -1.01883, -0.1126}, {-0.56048, -1.64764, -0.41412}, {-1.06174, -0.84818, -0.40858}, {-0.28371, -0.68079, -0.27444}, {0.0, 0.0, -0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{0.40559, 0.19141, 0.94402}, {0.02711, 0.52959, 1.51617}, {0.48474, -0.32507, 1.43352}, {-0.96491, -0.24844, 0.96363}, {-0.21888, -1.75451, 0.25449}, {-1.9409, -1.0444, -0.03488}, {-0.17851, -2.12392, 0.00497}, {-1.63733, -0.28292, 0.65268}, {0.8813, -1.0575, 1.18067}, {-0.8686, 0.97928, 1.61107}, {1.45171, -0.45294, 1.23516}, {-1.00119, 0.98635, 0.56507}, {1.00119, -0.98635, -0.56507}, {-1.45171, 0.45294, -1.23516}, {0.8686, -0.97928, -1.61107}, {-0.8813, 1.0575, -1.18067}, {1.63733, 0.28292, -0.65268}, {0.17851, 2.12392, -0.00497}, {1.9409, 1.0444, 0.03488}, {0.21888, 1.75451, -0.25449}, {0.96491, 0.24844, -0.96363}, {-0.48474, 0.32507, -1.43352}, {-0.02711, -0.52959, -1.51617}, {-0.40559, -0.19141, -0.94402}, {-0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    @Test
    public void ICAUnitVarExpTest1() {
        ICA obj = new ICA(this.X_fit, "exp", "unit-variance", this.w_init, 200, 1E-4, 1.0);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{0.35103, 0.68164, -0.17727}, {0.68012, 1.19474, 0.35167}, {0.9667, 1.41236, -0.52065}, {1.19279, 1.28082, 0.68127}, {1.34418, 0.83256, -0.83128}, {1.41125, 0.17867, 0.96809}, {1.38968, -0.51927, -1.08965}, {1.28069, -1.08837, 1.19409}, {1.09104, -1.38812, -1.27958}, {0.83258, -1.34414, 1.34504}, {0.52156, -0.96762, -1.38914}, {0.17759, -0.35148, 1.41143}, {-0.17759, 0.35148, -1.41143}, {-0.52156, 0.96762, 1.38914}, {-0.83258, 1.34414, -1.34504}, {-1.09104, 1.38812, 1.27958}, {-1.28069, 1.08837, -1.19409}, {-1.38968, 0.51927, 1.08965}, {-1.41125, -0.17867, -0.96809}, {-1.34418, -0.83256, 0.83128}, {-1.19279, -1.28082, -0.68127}, {-0.9667, -1.41236, 0.52065}, {-0.68012, -1.19474, -0.35167}, {-0.35103, -0.68164, 0.17727}, {0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{-0.35266, 0.96775, 0.17722}, {-0.6827, 1.41074, -0.35174}, {-0.96917, 1.08873, 0.52057}, {-1.19423, 0.17605, -0.68131}, {-1.34418, -0.83256, 0.83128}, {-1.41005, -1.39059, -0.96806}, {-1.38799, -1.1954, 1.0897}, {-1.27927, -0.353, -1.19405}, {-1.09034, 0.68026, 1.2796}, {-0.83258, 1.34414, -1.34504}, {-0.52187, 1.27914, 1.38913}, {-0.17776, 0.52039, -1.41144}, {0.17776, -0.52039, 1.41144}, {0.52187, -1.27914, -1.38913}, {0.83258, -1.34414, 1.34504}, {1.09034, -0.68026, -1.2796}, {1.27927, 0.353, 1.19405}, {1.38799, 1.1954, -1.0897}, {1.41005, 1.39059, 0.96806}, {1.34418, 0.83256, -0.83128}, {1.19423, -0.17605, 0.68131}, {0.96917, -1.08873, -0.52057}, {0.6827, -1.41074, 0.35174}, {0.35266, -0.96775, -0.17722}, {-0.0, -0.0, -0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    @Test
    public void ICAUnitVarCubeTest1() {
        ICA obj = new ICA(this.X_fit, "cube", "unit-variance", this.w_init, 200, 1E-4, 1.0);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{0.04458, -0.70543, 0.34593}, {0.72484, -1.09564, 0.53649}, {-0.00471, -1.49545, 0.98181}, {1.16394, -1.11197, 0.96754}, {-0.34385, -0.99693, 1.44183}, {1.25475, 0.02493, 1.17716}, {-0.8619, 0.26859, 1.60411}, {1.18097, 1.31164, 1.0656}, {-1.28554, 1.07846, 1.39244}, {1.17948, 1.59582, 0.60927}, {-1.42093, 0.647, 0.83689}, {1.31331, 0.64323, -0.09318}, {-1.31331, -0.64323, 0.09318}, {1.42093, -0.647, -0.83689}, {-1.17948, -1.59582, -0.60927}, {1.28554, -1.07846, -1.39244}, {-1.18097, -1.31164, -1.0656}, {0.8619, -0.26859, -1.60411}, {-1.25475, -0.02493, -1.17716}, {0.34385, 0.99693, -1.44183}, {-1.16394, 1.11197, -0.96754}, {0.00471, 1.49545, -0.98181}, {-0.72484, 1.09564, -0.53649}, {-0.04458, 0.70543, -0.34593}, {0.0, 0.0, 0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{0.2972, -0.9061, -0.42776}, {-0.18495, -1.45001, -0.66576}, {0.52298, -0.94821, -1.1059}, {-0.86206, -0.31144, -1.03982}, {0.34385, 0.99693, -1.44183}, {-1.50588, 1.15916, -1.11703}, {0.5066, 1.4067, -1.51904}, {-1.47964, 0.09664, -0.99409}, {1.13886, -0.38686, -1.35732}, {-1.17948, -1.59582, -0.60927}, {1.48548, -0.95136, -0.85234}, {-1.27831, -0.80826, 0.0848}, {1.27831, 0.80826, -0.0848}, {-1.48548, 0.95136, 0.85234}, {1.17948, 1.59582, 0.60927}, {-1.13886, 0.38686, 1.35732}, {1.47964, -0.09664, 0.99409}, {-0.5066, -1.4067, 1.51904}, {1.50588, -1.15916, 1.11703}, {-0.34385, -0.99693, 1.44183}, {0.86206, 0.31144, 1.03982}, {-0.52298, 0.94821, 1.1059}, {0.18495, 1.45001, 0.66576}, {-0.2972, 0.9061, 0.42776}, {-0.0, -0.0, -0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    // ARBITRARY VARIANCE
    @Test
    public void ICAArbitraryVarLogcoshTest1() {
        ICA obj = new ICA(this.X_fit, "logcosh", "arbitrary-variance", this.w_init, 200, 1E-4, 1);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{0.07023, 0.13632, -0.03546}, {0.13607, 0.23893, 0.07033}, {0.19338, 0.28244, -0.10414}, {0.2386, 0.25613, 0.13624}, {0.26886, 0.16647, -0.16626}, {0.28226, 0.03569, 0.19361}, {0.27791, -0.1039, -0.21794}, {0.25611, -0.21771, 0.23882}, {0.21816, -0.27766, -0.25592}, {0.16648, -0.26885, 0.26901}, {0.10427, -0.19355, -0.27783}, {0.03551, -0.0703, 0.28229}, {-0.03551, 0.0703, -0.28229}, {-0.10427, 0.19355, 0.27783}, {-0.16648, 0.26885, -0.26901}, {-0.21816, 0.27766, 0.25592}, {-0.25611, 0.21771, -0.23882}, {-0.27791, 0.1039, 0.21794}, {-0.28226, -0.03569, -0.19361}, {-0.26886, -0.16647, 0.16626}, {-0.2386, -0.25613, -0.13624}, {-0.19338, -0.28244, 0.10414}, {-0.13607, -0.23893, -0.07033}, {-0.07023, -0.13632, 0.03546}, {0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{-0.0705, 0.19356, 0.03544}, {-0.13649, 0.28217, -0.07035}, {-0.1938, 0.21778, 0.10412}, {-0.23884, 0.03525, -0.13626}, {-0.26886, -0.16647, 0.16626}, {-0.28206, -0.27807, -0.1936}, {-0.27763, -0.23903, 0.21795}, {-0.25587, -0.07056, -0.2388}, {-0.21804, 0.13609, 0.25592}, {-0.16648, 0.26885, -0.26901}, {-0.10433, 0.25585, 0.27782}, {-0.03554, 0.10408, -0.28229}, {0.03554, -0.10408, 0.28229}, {0.10433, -0.25585, -0.27782}, {0.16648, -0.26885, 0.26901}, {0.21804, -0.13609, -0.25592}, {0.25587, 0.07056, 0.2388}, {0.27763, 0.23903, -0.21795}, {0.28206, 0.27807, 0.1936}, {0.26886, 0.16647, -0.16626}, {0.23884, -0.03525, 0.13626}, {0.1938, -0.21778, -0.10412}, {0.13649, -0.28217, 0.07035}, {0.0705, -0.19356, -0.03544}, {-0.0, -0.0, -0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    @Test
    public void ICAArbitraryVarLogcoshTest2() {
        ICA obj = new ICA(this.X_fit, "logcosh", "arbitrary-variance", this.w_init, 200, 1E-4, 1.5);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{0.05674, 0.13616, 0.05489}, {0.21235, 0.16964, 0.08172}, {0.1121, 0.32953, 0.08282}, {0.31475, 0.20377, 0.02252}, {0.04378, 0.3509, -0.0509}, {0.28689, 0.08071, -0.17208}, {-0.10761, 0.24344, -0.25433}, {0.20699, -0.09586, -0.34349}, {-0.23542, 0.13664, -0.34072}, {0.17372, -0.19586, -0.32221}, {-0.2643, 0.12353, -0.20101}, {0.21436, -0.17941, -0.08806}, {-0.21436, 0.17941, 0.08806}, {0.2643, -0.12353, 0.20101}, {-0.17372, 0.19586, 0.32221}, {0.23542, -0.13664, 0.34072}, {-0.20699, 0.09586, 0.34349}, {0.10761, -0.24344, 0.25433}, {-0.28689, -0.08071, 0.17208}, {-0.04378, -0.3509, 0.0509}, {-0.31475, -0.20377, -0.02252}, {-0.1121, -0.32953, -0.08282}, {-0.21235, -0.16964, -0.08172}, {-0.05674, -0.13616, -0.05489}, {0.0, 0.0, -0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{0.08112, 0.03828, 0.1888}, {0.00542, 0.10592, 0.30323}, {0.09695, -0.06501, 0.2867}, {-0.19298, -0.04969, 0.19273}, {-0.04378, -0.3509, 0.0509}, {-0.38818, -0.20888, -0.00698}, {-0.0357, -0.42478, 0.00099}, {-0.32747, -0.05658, 0.13054}, {0.17626, -0.2115, 0.23613}, {-0.17372, 0.19586, 0.32221}, {0.29034, -0.09059, 0.24703}, {-0.20024, 0.19727, 0.11301}, {0.20024, -0.19727, -0.11301}, {-0.29034, 0.09059, -0.24703}, {0.17372, -0.19586, -0.32221}, {-0.17626, 0.2115, -0.23613}, {0.32747, 0.05658, -0.13054}, {0.0357, 0.42478, -0.00099}, {0.38818, 0.20888, 0.00698}, {0.04378, 0.3509, -0.0509}, {0.19298, 0.04969, -0.19273}, {-0.09695, 0.06501, -0.2867}, {-0.00542, -0.10592, -0.30323}, {-0.08112, -0.03828, -0.1888}, {-0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    @Test
    public void ICAArbitraryVarExpTest1() {
        ICA obj = new ICA(this.X_fit, "exp", "arbitrary-variance", this.w_init, 200, 1E-4, 1.0);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{0.07021, 0.13633, -0.03545}, {0.13602, 0.23895, 0.07033}, {0.19334, 0.28247, -0.10413}, {0.23856, 0.25616, 0.13625}, {0.26884, 0.16651, -0.16626}, {0.28225, 0.03573, 0.19362}, {0.27794, -0.10385, -0.21793}, {0.25614, -0.21767, 0.23882}, {0.21821, -0.27762, -0.25592}, {0.16652, -0.26883, 0.26901}, {0.10431, -0.19352, -0.27783}, {0.03552, -0.0703, 0.28229}, {-0.03552, 0.0703, -0.28229}, {-0.10431, 0.19352, 0.27783}, {-0.16652, 0.26883, -0.26901}, {-0.21821, 0.27762, 0.25592}, {-0.25614, 0.21767, -0.23882}, {-0.27794, 0.10385, 0.21793}, {-0.28225, -0.03573, -0.19362}, {-0.26884, -0.16651, 0.16626}, {-0.23856, -0.25616, -0.13625}, {-0.19334, -0.28247, 0.10413}, {-0.13602, -0.23895, -0.07033}, {-0.07021, -0.13633, 0.03545}, {0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{-0.07053, 0.19355, 0.03544}, {-0.13654, 0.28215, -0.07035}, {-0.19383, 0.21775, 0.10411}, {-0.23885, 0.03521, -0.13626}, {-0.26884, -0.16651, 0.16626}, {-0.28201, -0.27812, -0.19361}, {-0.2776, -0.23908, 0.21794}, {-0.25585, -0.0706, -0.23881}, {-0.21807, 0.13605, 0.25592}, {-0.16652, 0.26883, -0.26901}, {-0.10437, 0.25583, 0.27783}, {-0.03555, 0.10408, -0.28229}, {0.03555, -0.10408, 0.28229}, {0.10437, -0.25583, -0.27783}, {0.16652, -0.26883, 0.26901}, {0.21807, -0.13605, -0.25592}, {0.25585, 0.0706, 0.23881}, {0.2776, 0.23908, -0.21794}, {0.28201, 0.27812, 0.19361}, {0.26884, 0.16651, -0.16626}, {0.23885, -0.03521, 0.13626}, {0.19383, -0.21775, -0.10411}, {0.13654, -0.28215, 0.07035}, {0.07053, -0.19355, -0.03544}, {-0.0, -0.0, -0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    @Test
    public void ICAArbitraryVarCubeTest1() {
        ICA obj = new ICA(this.X_fit, "cube", "arbitrary-variance", this.w_init, 200, 1E-4, 1.0);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{0.00892, -0.14109, 0.06919}, {0.14497, -0.21913, 0.1073}, {-0.00094, -0.29909, 0.19636}, {0.23279, -0.22239, 0.19351}, {-0.06877, -0.19939, 0.28837}, {0.25095, 0.00499, 0.23543}, {-0.17238, 0.05372, 0.32082}, {0.23619, 0.26233, 0.21312}, {-0.25711, 0.21569, 0.27849}, {0.2359, 0.31916, 0.12185}, {-0.28419, 0.1294, 0.16738}, {0.26266, 0.12865, -0.01864}, {-0.26266, -0.12865, 0.01864}, {0.28419, -0.1294, -0.16738}, {-0.2359, -0.31916, -0.12185}, {0.25711, -0.21569, -0.27849}, {-0.23619, -0.26233, -0.21312}, {0.17238, -0.05372, -0.32082}, {-0.25095, -0.00499, -0.23543}, {0.06877, 0.19939, -0.28837}, {-0.23279, 0.22239, -0.19351}, {0.00094, 0.29909, -0.19636}, {-0.14497, 0.21913, -0.1073}, {-0.00892, 0.14109, -0.06919}, {0.0, 0.0, 0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{0.05944, -0.18122, -0.08555}, {-0.03699, -0.29, -0.13315}, {0.1046, -0.18964, -0.22118}, {-0.17241, -0.06229, -0.20796}, {0.06877, 0.19939, -0.28837}, {-0.30118, 0.23183, -0.22341}, {0.10132, 0.28134, -0.30381}, {-0.29593, 0.01933, -0.19882}, {0.22777, -0.07737, -0.27146}, {-0.2359, -0.31916, -0.12185}, {0.2971, -0.19027, -0.17047}, {-0.25566, -0.16165, 0.01696}, {0.25566, 0.16165, -0.01696}, {-0.2971, 0.19027, 0.17047}, {0.2359, 0.31916, 0.12185}, {-0.22777, 0.07737, 0.27146}, {0.29593, -0.01933, 0.19882}, {-0.10132, -0.28134, 0.30381}, {0.30118, -0.23183, 0.22341}, {-0.06877, -0.19939, 0.28837}, {0.17241, 0.06229, 0.20796}, {-0.1046, 0.18964, 0.22118}, {0.03699, 0.29, 0.13315}, {-0.05944, 0.18122, 0.08555}, {-0.0, -0.0, -0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    // NO WHITENING
    @Test
    public void ICANoWhitenVarLogcoshTest1() {
        ICA obj = new ICA(this.X_fit, "logcosh", "", this.w_init, 200, 1E-4, 1);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{1.73186, 0.04311, -0.29844}, {2.07737, 0.05957, -0.96572}, {4.24023, 0.06535, -0.60631}, {2.52033, 0.00934, -1.39284}, {4.65373, -0.03863, -0.30046}, {1.04846, -0.14585, -1.18981}, {3.45606, -0.19656, 0.41415}, {-1.12158, -0.28135, -0.75501}, {2.17049, -0.26209, 1.00511}, {-2.44235, -0.26424, -0.58406}, {1.9105, -0.15001, 1.10051}, {-2.41477, -0.07901, -0.80975}, {2.41477, 0.07901, 0.80975}, {-1.9105, 0.15001, -1.10051}, {2.44235, 0.26424, 0.58406}, {-2.17049, 0.26209, -1.00511}, {1.12158, 0.28135, 0.75501}, {-3.45606, 0.19656, -0.41415}, {-1.04846, 0.14585, 1.18981}, {-4.65373, 0.03863, 0.30046}, {-2.52033, -0.00934, 1.39284}, {-4.24023, -0.06535, 0.60631}, {-2.07737, -0.05957, 0.96572}, {-1.73186, -0.04311, 0.29844}, {0.0, -0.0, -0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{0.32883, 0.14798, -0.39291}, {1.17781, 0.24227, -0.12637}, {-1.11548, 0.22441, -0.44203}, {-0.70019, 0.15944, 0.78219}, {-4.65373, 0.03863, 0.30046}, {-2.56258, 0.00545, 1.69778}, {-5.59829, -0.00208, 0.30455}, {-0.6792, 0.11436, 1.35917}, {-3.05486, 0.18008, -0.70841}, {2.44235, 0.26424, 0.58406}, {-1.5213, 0.1861, -1.23109}, {2.6258, 0.09858, 0.73895}, {-2.6258, -0.09858, -0.73895}, {1.5213, -0.1861, 1.23109}, {-2.44235, -0.26424, -0.58406}, {3.05486, -0.18008, 0.70841}, {0.6792, -0.11436, -1.35917}, {5.59829, 0.00208, -0.30455}, {2.56258, -0.00545, -1.69778}, {4.65373, -0.03863, -0.30046}, {0.70019, -0.15944, -0.78219}, {1.11548, -0.22441, 0.44203}, {-1.17781, -0.24227, 0.12637}, {-0.32883, -0.14798, 0.39291}, {-0.0, 0.0, 0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    @Test
    public void ICANoWhitenVarLogcoshTest2() {
        ICA obj = new ICA(this.X_fit, "logcosh", "", this.w_init, 200, 1E-4, 1.5);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{1.73229, 0.04274, 0.29595}, {2.07876, 0.05923, 0.96274}, {4.24111, 0.06443, 0.60023}, {2.52233, 0.00896, 1.38923}, {4.65415, -0.0397, 0.29381}, {1.05013, -0.14591, 1.18833}, {3.45541, -0.19746, -0.41907}, {-1.12057, -0.28095, 0.75666}, {2.16898, -0.26277, -1.00817}, {-2.44157, -0.26356, 0.5876}, {1.90889, -0.15064, -1.10322}, {-2.41363, -0.0783, 0.81322}, {2.41363, 0.0783, -0.81322}, {-1.90889, 0.15064, 1.10322}, {2.44157, 0.26356, -0.5876}, {-2.16898, 0.26277, 1.00817}, {1.12057, 0.28095, -0.75666}, {-3.45541, 0.19746, 0.41907}, {-1.05013, 0.14591, -1.18833}, {-4.65415, 0.0397, -0.29381}, {-2.52233, -0.00896, -1.38923}, {-4.24111, -0.06443, -0.60023}, {-2.07876, -0.05923, -0.96274}, {-1.73229, -0.04274, -0.29595}, {0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{0.32943, 0.14796, 0.39241}, {1.17805, 0.24201, 0.12464}, {-1.11479, 0.22475, 0.44359}, {-0.70127, 0.15948, -0.78122}, {-4.65415, 0.0397, -0.29381}, {-2.56501, 0.00579, -1.69411}, {-5.59872, -0.00079, -0.29654}, {-0.68112, 0.1143, -1.35821}, {-3.0538, 0.18093, 0.71275}, {2.44157, 0.26356, -0.5876}, {-1.51949, 0.18666, 1.23323}, {2.62476, 0.09783, -0.74273}, {-2.62476, -0.09783, 0.74273}, {1.51949, -0.18666, -1.23323}, {-2.44157, -0.26356, 0.5876}, {3.0538, -0.18093, -0.71275}, {0.68112, -0.1143, 1.35821}, {5.59872, 0.00079, 0.29654}, {2.56501, -0.00579, 1.69411}, {4.65415, -0.0397, 0.29381}, {0.70127, -0.15948, 0.78122}, {1.11479, -0.22475, -0.44359}, {-1.17805, -0.24201, -0.12464}, {-0.32943, -0.14796, -0.39241}, {-0.0, 0.0, -0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    @Test
    public void ICANoWhitenVarExpTest1() {
        ICA obj = new ICA(this.X_fit, "exp", "", this.w_init, 200, 1E-4, 1.0);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{1.73369, -0.02959, -0.2893}, {2.0829, -0.03932, -0.95479}, {4.24378, -0.03307, -0.58367}, {2.52781, 0.0167, -1.37916}, {4.65492, 0.07162, -0.2749}, {1.05386, 0.16073, -1.1831}, {3.45238, 0.21682, 0.43422}, {-1.11936, 0.27888, -0.75922}, {2.16323, 0.26985, 1.0186}, {-2.44088, 0.25185, -0.59556}, {1.90349, 0.15541, 1.11185}, {-2.41085, 0.06831, -0.82232}, {2.41085, -0.06831, 0.82232}, {-1.90349, -0.15541, -1.11185}, {2.44088, -0.25185, 0.59556}, {-2.16323, -0.26985, -1.0186}, {1.11936, -0.27888, 0.75922}, {-3.45238, -0.21682, -0.43422}, {-1.05386, -0.16073, 1.1831}, {-4.65492, -0.07162, 0.2749}, {-2.52781, -0.0167, 1.37916}, {-4.24378, 0.03307, 0.58367}, {-2.0829, 0.03932, 0.95479}, {-1.73369, 0.02959, 0.2893}, {0.0, 0.0, -0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{0.33193, -0.14317, -0.39208}, {1.18007, -0.23358, -0.12156}, {-1.11155, -0.22889, -0.44956}, {-0.70331, -0.16929, 0.77731}, {-4.65492, -0.07162, 0.2749}, {-2.5716, -0.0338, 1.68376}, {-5.59973, -0.03723, 0.27413}, {-0.68574, -0.12791, 1.35467}, {-3.04972, -0.19571, -0.72618}, {2.44088, -0.25185, 0.59556}, {-1.51336, -0.18804, -1.24054}, {2.62238, -0.086, 0.75255}, {-2.62238, 0.086, -0.75255}, {1.51336, 0.18804, 1.24054}, {-2.44088, 0.25185, -0.59556}, {3.04972, 0.19571, 0.72618}, {0.68574, 0.12791, -1.35467}, {5.59973, 0.03723, -0.27413}, {2.5716, 0.0338, -1.68376}, {4.65492, 0.07162, -0.2749}, {0.70331, 0.16929, -0.77731}, {1.11155, 0.22889, 0.44956}, {-1.18007, 0.23358, 0.12156}, {-0.33193, 0.14317, 0.39208}, {-0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    @Test
    public void ICANoWhitenVarCubeTest1() {
        ICA obj = new ICA(this.X_fit, "cube", "", this.w_init, 200, 1E-4, 1.0);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{1.74558, -0.04784, -0.20224}, {2.12724, -0.07225, -0.84928}, {4.26706, -0.0755, -0.37143}, {2.59308, -0.02727, -1.25194}, {4.66326, 0.03168, -0.04452}, {1.11249, 0.13135, -1.13194}, {3.42833, 0.19873, 0.60129}, {-1.07799, 0.27347, -0.81872}, {2.11231, 0.27202, 1.11988}, {-2.40618, 0.25933, -0.72047}, {1.84731, 0.16124, 1.20212}, {-2.36649, 0.07149, -0.94216}, {2.36649, -0.07149, 0.94216}, {-1.84731, -0.16124, -1.20212}, {2.40618, -0.25933, 0.72047}, {-2.11231, -0.27202, -1.11988}, {1.07799, -0.27347, 0.81872}, {-3.42833, -0.19873, -0.60129}, {-1.11249, -0.13135, 1.13194}, {-4.66326, -0.03168, 0.04452}, {-2.59308, 0.02727, 1.25194}, {-4.26706, 0.0755, 0.37143}, {-2.12724, 0.07225, 0.84928}, {-1.74558, 0.04784, 0.20224}, {0.0, 0.0, -0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(S_[i], expected_S_[i], 0.0001);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{0.34973, -0.15274, -0.37251}, {1.18264, -0.24459, -0.05863}, {-1.0898, -0.22865, -0.5001}, {-0.74235, -0.1499, 0.74428}, {-4.66326, -0.03168, 0.04452}, {-2.65205, 0.01602, 1.55425}, {-5.60655, 0.00978, -0.0038}, {-0.75306, -0.09819, 1.32098}, {-3.01154, -0.18594, -0.87321}, {2.40618, -0.25933, 0.72047}, {-1.45157, -0.19912, -1.31067}, {2.58106, -0.09203, 0.88331}, {-2.58106, 0.09203, -0.88331}, {1.45157, 0.19912, 1.31067}, {-2.40618, 0.25933, -0.72047}, {3.01154, 0.18594, 0.87321}, {0.75306, 0.09819, -1.32098}, {5.60655, -0.00978, 0.0038}, {2.65205, -0.01602, -1.55425}, {4.66326, 0.03168, -0.04452}, {0.74235, 0.1499, -0.74428}, {1.0898, 0.22865, 0.5001}, {-1.18264, 0.24459, 0.05863}, {-0.34973, 0.15274, 0.37251}, {-0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(S_tr_[i], expected_S_tr_[i], 0.0001);
        }
    }

    // Randomly generated w_init
    @Test
    public void ICAUnitVarLogcoshRandomStateTest() {
        ICA obj = new ICA(this.X_fit, "logcosh", "unit-variance", 200, 1E-4, 1, 32);
        obj.fit();
        double[][] S_ = obj.transform();
        double[][] expected_S_ = {{0.35113, 0.68158, -0.17729}, {0.68033, 1.19464, 0.35163}, {0.96692, 1.4122, -0.52069}, {1.19302, 1.28063, 0.68122}, {1.34429, 0.83233, -0.83132}, {1.4113, 0.17845, 0.96806}, {1.38957, -0.51951, -1.08968}, {1.28054, -1.08856, 1.19408}, {1.09079, -1.38832, -1.27958}, {0.83239, -1.34425, 1.34504}, {0.52137, -0.96773, -1.38913}, {0.17757, -0.35149, 1.41143}, {-0.17757, 0.35149, -1.41143}, {-0.52137, 0.96773, 1.38913}, {-0.83239, 1.34425, -1.34504}, {-1.09079, 1.38832, 1.27958}, {-1.28054, 1.08856, -1.19408}, {-1.38957, 0.51951, 1.08968}, {-1.4113, -0.17845, -0.96806}, {-1.34429, -0.83233, 0.83132}, {-1.19302, -1.28063, -0.68122}, {-0.96692, -1.4122, 0.52069}, {-0.68033, -1.19464, -0.35163}, {-0.35113, -0.68158, 0.17729}, {0.0, -0.0, 0.0}};
        Assertions.assertEquals(S_.length, expected_S_.length);
        for (int i=0; i<expected_S_.length; i++) {
            Assertions.assertArrayEquals(UtilMethods.absoluteArray(S_[i]), UtilMethods.absoluteArray(expected_S_[i]), 0.005);
        }

        double[][] S_tr_ = obj.transform(this.X_tr);
        double[][] expected_S_tr_ = {{-0.3525, 0.96781, 0.17721}, {-0.68247, 1.41085, -0.35175}, {-0.96898, 1.08889, 0.52058}, {-1.19422, 0.17623, -0.68128}, {-1.34429, -0.83233, 0.83132}, {-1.4103, -1.39037, -0.968}, {-1.38815, -1.19516, 1.08975}, {-1.27936, -0.35281, -1.19402}, {-1.0902, 0.68046, 1.27961}, {-0.83239, 1.34425, -1.34504}, {-0.52163, 1.27925, 1.38912}, {-0.17771, 0.5204, -1.41144}, {0.17771, -0.5204, 1.41144}, {0.52163, -1.27925, -1.38912}, {0.83239, -1.34425, 1.34504}, {1.0902, -0.68046, -1.27961}, {1.27936, 0.35281, 1.19402}, {1.38815, 1.19516, -1.08975}, {1.4103, 1.39037, 0.968}, {1.34429, 0.83233, -0.83132}, {1.19422, -0.17623, 0.68128}, {0.96898, -1.08889, -0.52058}, {0.68247, -1.41085, 0.35175}, {0.3525, -0.96781, -0.17721}, {-0.0, -0.0, -0.0}};
        Assertions.assertEquals(S_tr_.length, expected_S_tr_.length);
        for (int i=0; i<expected_S_tr_.length; i++) {
            Assertions.assertArrayEquals(UtilMethods.absoluteArray(S_tr_[i]), UtilMethods.absoluteArray(expected_S_tr_[i]), 0.005);
        }
    }
}
